# db.py
import mysql.connector
import bcrypt
import json
from typing import List, Dict, Any

# ---------- Update these if your XAMPP MySQL has password / different user ----------
DB_CONFIG = {
    "host": "sql313.infinityfree.com",
    "user": "if0_40528967",
    "password": "wlXeL06y1w",        # <-- put your MySQL password if any
    "database": "if0_40528967_medguardian",
    "raise_on_warnings": True,
    "autocommit": False
}


def get_conn():
    return mysql.connector.connect(**DB_CONFIG)

# ----- User functions -----
def create_user(username: str, password: str, full_name: str = None, phone: str = None) -> bool:
    pw_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()
    conn = get_conn()
    cur = conn.cursor()
    try:
        cur.execute(
            "INSERT INTO users (username, password_hash, full_name, phone) VALUES (%s,%s,%s,%s)",
            (username, pw_hash, full_name, phone)
        )
        conn.commit()
        return True
    except mysql.connector.errors.IntegrityError:
        conn.rollback()
        return False
    finally:
        cur.close()
        conn.close()


def authenticate_user(username: str, password: str):
    conn = get_conn()
    cur = conn.cursor(dictionary=True)
    try:
        cur.execute("SELECT id, username, password_hash, full_name FROM users WHERE username = %s", (username,))
        row = cur.fetchone()
    finally:
        cur.close()
        conn.close()

    if not row:
        return None
    try:
        if bcrypt.checkpw(password.encode(), row["password_hash"].encode()):
            return {"id": row["id"], "username": row["username"], "full_name": row.get("full_name")}
    except Exception:
        return None
    return None

# ----- Report functions -----
def insert_report(user_id:int, report:Dict[str,Any]):
    conn = get_conn()
    cur = conn.cursor()
    try:
        cur.execute("""
            INSERT INTO reports (
                user_id, patient_id, patient_name, phone,
                doctor_name, referred_by, sample_collected,
                report_generated_by, date, condition_name, risk, raw_json
            ) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
        """, (
            user_id,
            report.get("Patient ID"),
            report.get("Patient Name"),
            report.get("Phone"),
            report.get("Doctor Name"),
            report.get("Referred By"),
            report.get("Sample Collected"),
            report.get("Report Generated By"),
            report.get("Date"),
            report.get("Condition"),
            float(report.get("Risk %", 0)),
            json.dumps(report, default=str)
        ))
        conn.commit()
    except Exception:
        conn.rollback()
        raise
    finally:
        cur.close()
        conn.close()


def get_reports_for_user(user_id:int, limit=1000) -> List[Dict[str,Any]]:
    conn = get_conn()
    cur = conn.cursor(dictionary=True)
    try:
        cur.execute("SELECT * FROM reports WHERE user_id = %s ORDER BY created_at DESC LIMIT %s", (user_id, limit))
        rows = cur.fetchall()
    finally:
        cur.close()
        conn.close()

    for r in rows:
        try:
            r['raw'] = json.loads(r.get('raw_json') or '{}')
        except Exception:
            r['raw'] = {}
    return rows


def get_filtered_reports(user_id:int, condition: str = None, patient_name: str = None):
    conn = get_conn()
    cur = conn.cursor(dictionary=True)
    try:
        q = "SELECT * FROM reports WHERE user_id = %s"
        params = [user_id]
        if condition:
            q += " AND condition_name = %s"
            params.append(condition)
        if patient_name:
            q += " AND patient_name = %s"
            params.append(patient_name)
        q += " ORDER BY created_at DESC"
        cur.execute(q, tuple(params))
        rows = cur.fetchall()
    finally:
        cur.close()
        conn.close()
    return rows

# ----- Delete report -----
def delete_report(report_id: int) -> bool:
    """
    Delete a report by its primary key id.
    Returns True if a row was deleted, False if 0 rows affected.
    Raises exception on DB/connect error.
    """
    if not report_id:
        raise ValueError("delete_report called with empty report_id")

    conn = get_conn()
    cur = conn.cursor()
    try:
        sql = "DELETE FROM reports WHERE id = %s"
        cur.execute(sql, (report_id,))
        affected = cur.rowcount
        conn.commit()
        return affected > 0
    except Exception:
        try:
            conn.rollback()
        except:
            pass
        raise
    finally:
        try:
            cur.close()
        except:
            pass
        try:
            conn.close()
        except:
            pass

# ----- Chat functions -----
def insert_chat(user_id:int, role:str, message:str):
    conn = get_conn()
    cur = conn.cursor()
    try:
        cur.execute("INSERT INTO chats (user_id, role, message) VALUES (%s,%s,%s)", (user_id, role, message))
        conn.commit()
    except Exception:
        conn.rollback()
        raise
    finally:
        cur.close()
        conn.close()


def get_chats_for_user(user_id:int, limit=500):
    conn = get_conn()
    cur = conn.cursor(dictionary=True)
    try:
        cur.execute("SELECT * FROM chats WHERE user_id = %s ORDER BY created_at ASC LIMIT %s", (user_id, limit))
        rows = cur.fetchall()
    finally:
        cur.close()
        conn.close()
    return rows
